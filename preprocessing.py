"""
Contains code for reading inputs and any preprocessing necessary to make our algorithm work, and our database connection
"""

import psycopg2
import re
import itertools
import sqlparse
import json
from psycopg2 import sql
from tqdm import tqdm
from sqlparse.sql import IdentifierList, Identifier
from sqlparse.tokens import Keyword, DML
import queue


class Database:
  def __init__(self, host="localhost", port=5432, database="TPC-H", user="postgres", password="database"):
    # Connect to postgres database called TPC-H
    self.conn = psycopg2.connect(host=host, port=port, database=database, user=user, password=password)
    # Create a cursor to perform database operations
    self.cur = self.conn.cursor()

  # Method for executing query and returning the results
  def execute(self,query):
    self.cur.execute(query)
    query_results = self.cur.fetchall()
    return query_results

  def close(self):
    self.cur.close()
    self.conn.close()


class SQLParser:
  def __init__(self):
    pass


class Node(object):    
  """
  Node class defines the structure of the data that an individual node of the Query Execution Plan can store
  as well as the functions that can be performed on it.
  Args:
      object (Node): Node of QEP
  """
  def __init__(self, node_type, relation_name, schema, alias, group_key, sort_key, join_type, index_name, 
              hash_condition, table_filter, index_condition, merge_condition, recheck_condition, join_filter, subplan_name, actual_rows,
              actual_time,description):
    self.node_type = node_type
    self.children = []
    self.relation_name = relation_name
    self.schema = schema
    self.alias = alias
    self.group_key = group_key
    self.sort_key = sort_key
    self.join_type = join_type
    self.index_name = index_name
    self.hash_condition = hash_condition
    self.table_filter = table_filter
    self.index_condition = index_condition
    self.merge_condition = merge_condition
    self.recheck_condition = recheck_condition
    self.join_filter = join_filter
    self.subplan_name = subplan_name
    self.actual_rows = actual_rows
    self.actual_time = actual_time
    self.description = description

  def append_children(self, child):
    self.children.append(child)
  
  def write_qep_output_name(self, output_name):
    if "T" == output_name[0] and output_name[1:].isdigit():
      self.output_name = int(output_name[1:])
    else:
      self.output_name = output_name

  def read_qep_output_name(self):
    if str(self.output_name).isdigit():
      return "T" + str(self.output_name)
    else:
      return self.output_name

  def set_step(self, step):
    self.step = step
  
  def update_desc(self,desc):
    self.description = desc


class QueryPlans:
  def __init__(self, sql_query):
    self.connection = Database()
    self.sql_query = sql_query

  
  def generateQEP(self):
    return self.connection.execute(f"EXPLAIN (format json) {self.sql_query}")

  def generateAQPs(self, qep_node_types):
    aqps = []
    prev_condition = None
    for nt in qep_node_types:
      if nt == "Nested Loop":
        condition = "enable_nestloop"
      elif nt == "Seq Scan":
        condition = "enable_seqscan"
      elif nt == "Index Scan":
        condition = "enable_indexscan"
      elif nt == "Bitmap Index Scan" or nt == "Bitmap Heap Scan":
        condition = "enable_bitmapscan"
      elif nt == "Hash Join":
        condition = "enable_hashjoin"
      elif nt == "Merge Join":
        condition = "enable_mergejoin"
      if prev_condition:
        aqps.append(self.connection.execute(f"set {prev_condition} = 'on'; set {condition} = 'off'; EXPLAIN (format json) {self.sql_query}"))
      else:
        aqps.append(self.connection.execute(f"set {condition} = 'off'; EXPLAIN (format json) {self.sql_query}"))
      prev_condition = condition
    return aqps


  def extract_qep_data(self, json_obj):
    """
    This function parses the QEP in JSON format and stores the attributes generated by the EXPLAIN ANALYZE query.
    Args:
        qep_json_obj (json): QEP generated from EXPLAIN (ANALYSE, COSTS, VERBOSE, BUFFERS, FORMAT JSON) query.
    Returns:
        Node: Returns the root node of the generated QEP tree. 
    """

    # q_child_plans : Queue to store all child plans
    # q_parent_plans : Queue to store parents of all child plans
    q_child_plans = queue.Queue()
    q_parent_plans = queue.Queue()
    plan = json_obj[0]['Plan']
    q_child_plans.put(plan)
    q_parent_plans.put(None)
    node_types = set()

    while not q_child_plans.empty():
      current_plan = q_child_plans.get()
      parent_node = q_parent_plans.get()

      relation_name = schema = alias = group_key = sort_key = join_type = index_name = hash_condition = table_filter \
        = index_condition = merge_condition = recheck_condition = join_filter = subplan_name = actual_rows = actual_time = description = None
      if 'Relation Name' in current_plan:
          relation_name = current_plan['Relation Name']
      if 'Schema' in current_plan:
          schema = current_plan['Schema']
      if 'Alias' in current_plan:
          alias = current_plan['Alias']
      if 'Group Key' in current_plan:
          group_key = current_plan['Group Key']
      if 'Sort Key' in current_plan:
          sort_key = current_plan['Sort Key']
      if 'Join Type' in current_plan:
          join_type = current_plan['Join Type']
      if 'Index Name' in current_plan:
          index_name = current_plan['Index Name']
      if 'Hash Cond' in current_plan:
          hash_condition = current_plan['Hash Cond']
      if 'Filter' in current_plan:
          table_filter = current_plan['Filter']
      if 'Index Cond' in current_plan:
          index_condition = current_plan['Index Cond']
      if 'Merge Cond' in current_plan:
          merge_condition = current_plan['Merge Cond']
      if 'Recheck Cond' in current_plan:
          recheck_condition = current_plan['Recheck Cond']
      if 'Join Filter' in current_plan:
          join_filter = current_plan['Join Filter']
      if 'Actual Rows' in current_plan:
          actual_rows = current_plan['Actual Rows']
      if 'Actual Total Time' in current_plan:
          actual_time = current_plan['Actual Total Time']
      if 'Subplan Name' in current_plan:
        if "returns" in current_plan['Subplan Name']:
          name = current_plan['Subplan Name']
          subplan_name = name[name.index("$"):-1]
        else:
          subplan_name = current_plan['Subplan Name']
      # form a node form attributes created above
      current_node = Node(current_plan['Node Type'], relation_name, schema, alias, group_key, sort_key, join_type,
                          index_name, hash_condition, table_filter, index_condition, merge_condition, recheck_condition, join_filter,
                          subplan_name, actual_rows, actual_time, description)
      node_types.add(current_node.node_type)
      # Parse for the various nodetypes. Some of the most common ones are : Seq Scan, Index Only Scan, 
      # Index Scan, Bitmap Index/Heap Scan, Limit, Sort and Nested Loop. 
        
      if current_node.node_type == "Limit":
        current_node.plan_rows = current_plan['Plan Rows']

      if "Scan" in current_node.node_type:
        if "Index" in current_node.node_type:
          if relation_name:
            current_node.write_qep_output_name("{} with index {}".format(relation_name, index_name))
        elif "Subquery" in current_node.node_type:
          current_node.write_qep_output_name(alias)
        else:
          current_node.write_qep_output_name(relation_name)

      if parent_node:
        parent_node.append_children(current_node)
      else:
        root_node = current_node

      if 'Plans' in current_plan:
        for item in current_plan['Plans']:
          # push child plans into queue
          q_child_plans.put(item)
          # push parent for each child into queue
          q_parent_plans.put(current_node)

    return root_node, node_types

if __name__ == "__main__":
  query = 'select N.n_name, R.r_name from nation N, region R where N.n_regionkey=1 and N.n_regionkey=R.r_regionkey'
  qp = QueryPlans(query)
  output = qp.generateQEP()
  print(output)
  print('\n')

  query_result = json.loads(json.dumps(output[0][0]))
  print(query_result[0]['Plan'])